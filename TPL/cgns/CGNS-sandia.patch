From a033149ebaa3dd04fe89dddaa128b6006b64ff42 Mon Sep 17 00:00:00 2001
From: Greg Sjaardema <gsjaardema@gmail.com>
Date: Mon, 4 Feb 2019 10:11:09 -0700
Subject: [PATCH] SANDIA-specific patches

* Proof-of-concept for allowing file-per-processor and single-file parallel output
* Compact Storage Rev patch
---
 src/adfh/ADFH.c      | 29 ++++++++++++++++++++++-
 src/adfh/ADFH.h      |  1 +
 src/cgns_internals.c | 19 +++++++++++++--
 src/cgns_io.c        | 56 ++++++++++++++++++++++++++++++++++++++------
 src/cgns_io.h        |  4 ++++
 src/cgnslib.c        | 53 +++++++++++++++++++++++++++++++++++++----
 src/cgnslib.h        |  6 +++++
 7 files changed, 153 insertions(+), 15 deletions(-)

diff --git a/src/adfh/ADFH.c b/src/adfh/ADFH.c
index 3ef506e..79d978d 100644
--- a/src/adfh/ADFH.c
+++ b/src/adfh/ADFH.c
@@ -65,6 +65,9 @@ static MPI_Comm ParallelMPICommunicator = MPI_COMM_WORLD;
 
 #define TO_UPPER( c ) ((islower(c))?(toupper(c)):(c))
 
+/* HDF5 compact storage limit */
+#define CGNS_64KB (64 * 1024)
+
 /*
  * ADF names are not allowed to start with a space.
  * Since HDF5 allows this, use the space to hide data
@@ -711,6 +714,7 @@ static int new_str_data(hid_t id, const char *name, const char *value,
   hsize_t dim;
   herr_t status;
   hid_t xfer_prp=H5P_DEFAULT;
+  hid_t dcpl_id=H5P_DEFAULT;
 
   dim = size+1;
   sid = H5Screate_simple(1, &dim, NULL);
@@ -719,9 +723,18 @@ static int new_str_data(hid_t id, const char *name, const char *value,
     return 1;
   }
 
-  did = H5Dcreate2(id, name, H5T_NATIVE_CHAR, sid, H5P_DEFAULT, H5P_DEFAULT, H5P_DEFAULT);
+  dcpl_id = H5Pcreate(H5P_DATASET_CREATE);
+
+  /* compact storage */
+  if(size+1 < CGNS_64KB)
+    H5Pset_layout(dcpl_id, H5D_COMPACT);
+  else
+    H5Pset_layout(dcpl_id, H5D_CONTIGUOUS);
+
+  did = H5Dcreate2(id, name, H5T_NATIVE_CHAR, sid, H5P_DEFAULT, dcpl_id, H5P_DEFAULT);
   if (did < 0) {
     H5Sclose(sid);
+    H5Pclose(dcpl_id);
     set_error(ADFH_ERR_DCREATE, err);
     return 1;
   }
@@ -743,6 +756,7 @@ static int new_str_data(hid_t id, const char *name, const char *value,
 
   H5Dclose(did);
   H5Sclose(sid);
+  H5Pclose(dcpl_id);
 
   if (status < 0) {
     set_error(ADFH_ERR_DWRITE, err);
@@ -2616,6 +2630,7 @@ void ADFH_Put_Dimension_Information(const double   id,
                                     const char    *data_type,
                                     const int      dims,
                                     const cgsize_t dim_vals[],
+                                    const int      HDF5storage_type,
                                     int           *err)
 {
   hid_t hid;
@@ -2708,6 +2723,17 @@ void ADFH_Put_Dimension_Information(const double   id,
   H5Pset_chunk(mta_root->g_propdataset, dims, new_dims);
 #endif
 
+  hssize_t dset_size = H5Sget_select_npoints(sid);
+  size_t dtype_size = H5Tget_size(tid); 
+
+  /* Chunked datasets are currently not supported */
+
+  /* Compact storage has a dataset size limit of 64 KiB */
+  if(HDF5storage_type == CGIO_COMPACT && dset_size*(hssize_t)dtype_size  < (hssize_t)CGNS_64KB)
+    H5Pset_layout(mta_root->g_propdataset, H5D_COMPACT);
+  else
+    H5Pset_layout(mta_root->g_propdataset, H5D_CONTIGUOUS);
+
   ADFH_CHECK_HID(sid);
   did = H5Dcreate2(hid, D_DATA, tid, sid,
 		   H5P_DEFAULT, mta_root->g_propdataset, H5P_DEFAULT);
@@ -2843,6 +2869,7 @@ void ADFH_Link(const double  pid,
   if (new_str_data(lid,D_PATH,name_in_file,(int)strlen(name_in_file),err)) return;
   if (*file && new_str_data(lid,D_FILE,file,(int)strlen(file),err))        return;
 #ifndef ADFH_FORCE_ID_CLOSE
+  hid_t hid;
   to_HDF_ID(pid,hid);
   track_id(hid,lid);
 #endif
diff --git a/src/adfh/ADFH.h b/src/adfh/ADFH.h
index 048aed4..ac88058 100644
--- a/src/adfh/ADFH.h
+++ b/src/adfh/ADFH.h
@@ -350,6 +350,7 @@ EXTERN	void	ADFH_Put_Dimension_Information(
 			const char *data_type,
 			const int dims,
 			const cgsize_t dim_vals[],
+                        const int HDF5storage_type,
 			int *error_return ) ;
 
 EXTERN	void	ADFH_Put_Name(
diff --git a/src/cgns_internals.c b/src/cgns_internals.c
index 1d2dee0..70a7911 100644
--- a/src/cgns_internals.c
+++ b/src/cgns_internals.c
@@ -40,6 +40,9 @@ freely, subject to the following restrictions:
 
 #define CGNS_NAN(x)  (!((x) < HUGE_VAL && (x) > -HUGE_VAL))
 
+/* Flag for contiguous (0) or compact storage (1) */
+extern int HDF5storage_type;
+
 /***********************************************************************
  * global variable definitions
  ***********************************************************************/
@@ -89,8 +92,8 @@ int cgi_read()
     double *id;
 
      /* get number of CGNSBase_t nodes and their ID */
-
     if (cgi_get_nodes(cg->rootid, "CGNSBase_t", &cg->nbases, &id)) return CG_ERROR;
+
     if (cg->nbases==0) return CG_OK;
     cg->base = CGNS_NEW(cgns_base,cg->nbases);
     for (b=0; b<cg->nbases; b++) cg->base[b].id = id[b];
@@ -6132,6 +6135,8 @@ int cgi_write_section(double parent_id, cgns_section *section)
     cgsize_t dim_vals;
     double dummy_id;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
     if (section->link) {
         return cgi_write_link(parent_id, section->name,
             section->link, &section->id);
@@ -6170,6 +6175,7 @@ int cgi_write_section(double parent_id, cgns_section *section)
     for (n=0; n<section->nuser_data; n++)
         if (cgi_write_user_data(section->id, &section->user_data[n])) return CG_ERROR;
 
+    HDF5storage_type = CG_COMPACT;
     return CG_OK;
 }
 
@@ -6350,6 +6356,8 @@ int cgi_write_conns(double parent_id, cgns_conn *conn)
     double dummy_id;
     cgns_ptset *ptset;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
     if (conn->link) {
         return cgi_write_link(parent_id, conn->name,
             conn->link, &conn->id);
@@ -6406,6 +6414,8 @@ int cgi_write_conns(double parent_id, cgns_conn *conn)
     for (n=0; n<conn->nuser_data; n++)
         if (cgi_write_user_data(conn->id, &conn->user_data[n])) return CG_ERROR;
 
+    HDF5storage_type = CG_COMPACT;
+
     return CG_OK;
 }
 
@@ -7511,6 +7521,8 @@ int cgi_write_array(double parent_id, cgns_array *array)
     cgsize_t dim_vals;
     double dummy_id;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
     if (array->link) {
         return cgi_write_link(parent_id, array->name,
             array->link, &array->id);
@@ -7551,6 +7563,8 @@ int cgi_write_array(double parent_id, cgns_array *array)
                          &dummy_id, "I4", 1, &dim_vals, array->range))
             return CG_ERROR;
 
+    HDF5storage_type = CG_COMPACT;
+
     return CG_OK;
 }
 
@@ -11710,7 +11724,7 @@ int *cgi_rind_address(int local_mode, int *ier)
 {
     int *rind_planes=0, nnod;
     double parent_id=0, *id;
-    int error1=0, index_dim;
+    int error1, index_dim;
 
     /* check for valid posit */
     if (posit == 0) {
@@ -11750,6 +11764,7 @@ int *cgi_rind_address(int local_mode, int *ier)
     }
 
 /* Corrected on July 27 2001 by Diane Poirier
+    
     if (error1==1) {
         cgi_error("Rind_t already defined under %s",posit->label);
         (*ier) = CG_ERROR;
diff --git a/src/cgns_io.c b/src/cgns_io.c
index 1d8a194..8b5107b 100644
--- a/src/cgns_io.c
+++ b/src/cgns_io.c
@@ -50,12 +50,12 @@ char hdf5_access[64] = "NATIVE";
 #ifdef MEM_DEBUG
 #include "cg_malloc.h"
 #endif
+int pcg_mpi_initialized;
 #if CG_BUILD_PARALLEL
 #include <mpi.h>
 MPI_Comm pcg_mpi_comm=MPI_COMM_WORLD;
 int pcg_mpi_comm_size;
 int pcg_mpi_comm_rank;
-int pcg_mpi_initialized;
 MPI_Info pcg_mpi_info;
 #endif
 
@@ -67,10 +67,13 @@ MPI_Info pcg_mpi_info;
 #endif
 #endif
 
+/* Flag for contiguous or compact HDF5 storage */
+extern int HDF5storage_type;
 
 typedef struct {
     int type;
     int mode;
+    int mpi_initialized;
     double rootid;
 } cgns_io;
 
@@ -589,7 +592,7 @@ int cgio_check_file (const char *filename, int *file_type)
 
 #if CG_BUILD_PARALLEL
     /* don't overload the file system by having all the processors doing a read */
-    if(pcg_mpi_comm_rank == 0) {
+    if(!pcg_mpi_initialized || pcg_mpi_comm_rank == 0) {
 #endif
 
       fp = fopen(filename, "rb");
@@ -805,6 +808,11 @@ int cgio_open_file (const char *filename, int file_mode,
     }
     iolist[n].type = file_type;
     iolist[n].mode = file_mode;
+#if CG_BUILD_PARALLEL
+    iolist[n].mpi_initialized = pcg_mpi_initialized;
+#else
+    iolist[n].mpi_initialized = 0;
+#endif
     iolist[n].rootid = rootid;
     *cgio_num = n + 1;
     num_open++;
@@ -816,8 +824,8 @@ int cgio_open_file (const char *filename, int file_mode,
 
 int cgio_close_file (int cgio_num)
 {
-    int ierr;
-    cgns_io *cgio;
+    int ierr = 0;
+    cgns_io *cgio = NULL;
 
     if ((cgio = get_cgnsio(cgio_num, 0)) == NULL)
         return get_error();
@@ -828,6 +836,7 @@ int cgio_close_file (int cgio_num)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Database_Close(cgio->rootid, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -913,6 +922,7 @@ int cgio_flush_to_disk (int cgio_num)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Flush_to_Disk(cgio->rootid, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -942,6 +952,7 @@ int cgio_library_version (int cgio_num, char *version)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Library_Version(version, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -971,6 +982,7 @@ int cgio_file_version (int cgio_num, char *file_version,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Database_Version(cgio->rootid, file_version,
             creation_date, modified_date, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1093,6 +1105,7 @@ int cgio_create_node (int cgio_num, double pid,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Create(pid, name, id, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1132,12 +1145,13 @@ int cgio_new_node (int cgio_num, double pid, const char *name,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Create(pid, name, id, &ierr);
         if (ierr > 0) return set_error(ierr);
         ADFH_Set_Label(*id, label, &ierr);
         if (ierr > 0) return set_error(ierr);
         if (data_type != NULL && strcmp(data_type, "MT")) {
-            ADFH_Put_Dimension_Information(*id, data_type, ndims, dims, &ierr);
+            ADFH_Put_Dimension_Information(*id, data_type, ndims, dims, HDF5storage_type, &ierr);
             if (ierr > 0) return set_error(ierr);
             if (data != NULL) {
                 ADFH_Write_All_Data(*id, NULL, (const char *)data, &ierr);
@@ -1169,6 +1183,7 @@ int cgio_delete_node (int cgio_num, double pid, double id)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Delete(pid, id, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1197,6 +1212,7 @@ int cgio_move_node (int cgio_num, double pid, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Move_Child(pid, id, new_pid, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1297,7 +1313,7 @@ int cgio_copy_node (int cgio_num_inp, double id_inp,
         ADFH_Set_Label(id_out, label, &ierr);
         if (ierr <= 0) {
             ADFH_Put_Dimension_Information(id_out, data_type, ndims,
-                dims, &ierr);
+                                           dims, HDF5storage_type, &ierr);
             if (ierr <= 0 && data_size)
                 ADFH_Write_All_Data(id_out, NULL, (const char *)data, &ierr);
         }
@@ -1323,6 +1339,7 @@ int cgio_release_id (int cgio_num, double id)
     if ((cgio = get_cgnsio(cgio_num, 0)) == NULL)
         return get_error();
     if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Release_ID(id);
     }
 #endif
@@ -1348,6 +1365,7 @@ int cgio_is_link (int cgio_num, double id, int *link_len)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Is_Link(id, link_len, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1376,6 +1394,7 @@ int cgio_link_size (int cgio_num, double id, int *file_len,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Link_Size(id, file_len, name_len, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1404,6 +1423,7 @@ int cgio_create_link (int cgio_num, double pid, const char *name,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Link(pid, name, filename, name_in_file, id, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1432,6 +1452,7 @@ int cgio_get_link (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Get_Link_Path(id, filename, name_in_file, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1462,6 +1483,7 @@ int cgio_number_children (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Number_of_Children(id, num_children, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1490,6 +1512,7 @@ int cgio_children_ids (int cgio_num, double pid,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Children_IDs(pid, start, max_ret, num_ret, ids, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1519,6 +1542,7 @@ int cgio_children_names (int cgio_num, double pid, int start, int max_ret,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Children_Names(pid, start, max_ret, name_len,
             num_ret, names, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1550,6 +1574,7 @@ int cgio_get_node_id (int cgio_num, double pid,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Get_Node_ID(pid, name, id, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1577,6 +1602,7 @@ int cgio_get_name (int cgio_num, double id, char *name)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Get_Name(id, name, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1604,6 +1630,7 @@ int cgio_get_label (int cgio_num, double id, char *label)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Get_Label(id, label, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1631,6 +1658,7 @@ int cgio_get_data_type (int cgio_num, double id, char *data_type)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Get_Data_Type(id, data_type, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1680,6 +1708,7 @@ int cgio_get_dimensions (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Get_Number_of_Dimensions(id, num_dims, &ierr);
         if (NULL != dims && ierr <= 0 && *num_dims > 0) {
             ADFH_Get_Dimension_Values(id, dims, &ierr);
@@ -1710,6 +1739,7 @@ int cgio_read_all_data (int cgio_num, double id, void *data)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Read_All_Data(id, NULL, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1739,6 +1769,7 @@ int cgio_read_all_data_type (int cgio_num, double id, const char *m_data_type,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Read_All_Data(id, m_data_type, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1767,6 +1798,7 @@ int cgio_read_block_data (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Read_Block_Data(id, b_start, b_end, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1799,6 +1831,7 @@ int cgio_read_data (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Read_Data(id, s_start, s_end, s_stride, NULL, m_num_dims,
             m_dims, m_start, m_end, m_stride, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1832,6 +1865,7 @@ int cgio_read_data_type (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Read_Data(id, s_start, s_end, s_stride, m_data_type, m_num_dims,
             m_dims, m_start, m_end, m_stride, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -1863,6 +1897,7 @@ int cgio_set_name (int cgio_num, double pid, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Put_Name(pid, id, name, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1890,6 +1925,7 @@ int cgio_set_label (int cgio_num, double id, const char *label)
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Set_Label(id, label, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1918,7 +1954,8 @@ int cgio_set_dimensions (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
-        ADFH_Put_Dimension_Information(id, data_type, num_dims, dims, &ierr);
+        pcg_mpi_initialized = cgio->mpi_initialized;
+        ADFH_Put_Dimension_Information(id, data_type, num_dims, dims, HDF5storage_type, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
 #endif
@@ -1946,6 +1983,7 @@ int cgio_write_all_data (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Write_All_Data(id, NULL, (const char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -1975,6 +2013,7 @@ int cgio_write_all_data_type (int cgio_num, double id, const char *m_data_type,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Write_All_Data(id, m_data_type, (const char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -2003,6 +2042,7 @@ int cgio_write_block_data (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Write_Block_Data(id, b_start, b_end, (char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
     }
@@ -2035,6 +2075,7 @@ int cgio_write_data (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Write_Data(id, s_start, s_end, s_stride, NULL, m_num_dims,
             m_dims, m_start, m_end, m_stride, (const char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
@@ -2068,6 +2109,7 @@ int cgio_write_data_type (int cgio_num, double id,
     }
 #if CG_BUILD_HDF5
     else if (cgio->type == CGIO_FILE_HDF5) {
+        pcg_mpi_initialized = cgio->mpi_initialized;
         ADFH_Write_Data(id, s_start, s_end, s_stride, m_data_type, m_num_dims,
             m_dims, m_start, m_end, m_stride, (const char *)data, &ierr);
         if (ierr > 0) return set_error(ierr);
diff --git a/src/cgns_io.h b/src/cgns_io.h
index aa10991..10001fd 100644
--- a/src/cgns_io.h
+++ b/src/cgns_io.h
@@ -49,6 +49,10 @@
 #define CGIO_FILE_HDF5   2
 #define CGIO_FILE_ADF2   3
 
+#define CGIO_CONTIGUOUS 0
+#define CGIO_COMPACT    1
+#define CGIO_CHUNKED    2
+
 /* currently these are the same as for ADF */
 
 #define CGIO_MAX_DATATYPE_LENGTH  2
diff --git a/src/cgnslib.c b/src/cgnslib.c
index 6530ddf..955ef16 100644
--- a/src/cgnslib.c
+++ b/src/cgnslib.c
@@ -98,6 +98,9 @@ int cgns_compress = 0;
 int cgns_filetype = CG_FILE_NONE;
 void* cgns_rindindex = CG_CONFIG_RIND_CORE;
 
+/* Flag for contiguous (0) or compact storage (1) */
+int HDF5storage_type = CG_COMPACT;
+
 extern void (*cgns_error_handler)(int, char *);
 
 /***********************************************************************
@@ -2270,6 +2273,14 @@ int cg_coord_write(int file_number, int B, int Z, CGNS_ENUMT(DataType_t) type,
     cgns_zcoor *zcoor;
     int n, m_numdim;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
+     /* verify input */
+    if (cgi_check_strlen(coordname)) return CG_ERROR;
+    if (type!=CGNS_ENUMV( RealSingle ) && type!=CGNS_ENUMV( RealDouble )) {
+        cgi_error("Invalid datatype for coord. array:  %d", type);
+        return CG_ERROR;
+    }
      /* get memory addresses */
     cg = cgi_get_file(file_number);
     if (cg == 0) return CG_ERROR;
@@ -2316,6 +2327,7 @@ int cg_coord_partial_write(int file_number, int B, int Z,
 {
     cgns_zone *zone;
     int n, m_numdim;
+    int status;
 
      /* get memory addresses */
     cg = cgi_get_file(file_number);
@@ -2339,10 +2351,13 @@ int cg_coord_partial_write(int file_number, int B, int Z,
         m_dimvals[n] = m_rmax[n];
     }
 
-    return cg_coord_general_write(file_number, B, Z, coordname,
+    status = cg_coord_general_write(file_number, B, Z, coordname,
                                   type, s_rmin, s_rmax,
                                   type, m_numdim, m_dimvals, m_rmin, m_rmax,
                                   coord_ptr, C);
+
+    HDF5storage_type = CG_COMPACT;
+    return status;
 }
 
 int cg_coord_general_write(int fn, int B, int Z, const char *coordname,
@@ -2357,6 +2372,9 @@ int cg_coord_general_write(int fn, int B, int Z, const char *coordname,
     cgns_zone *zone;
     cgns_zcoor *zcoor;
     int n, s_numdim;
+    int status;
+
+    HDF5storage_type = CG_CONTIGUOUS;
 
      /* verify input */
     if (cgi_check_strlen(coordname)) return CG_ERROR;
@@ -2411,12 +2429,14 @@ int cg_coord_general_write(int fn, int B, int Z, const char *coordname,
         return CG_ERROR;
     }
 
-    return cgi_array_general_write(zcoor->id, &(zcoor->ncoords),
+    status = cgi_array_general_write(zcoor->id, &(zcoor->ncoords),
                                    &(zcoor->coord), coordname,
                                    cgns_rindindex, zcoor->rind_planes,
                                    s_type, s_numdim, s_dimvals, s_rmin, s_rmax,
                                    m_type, m_numdim, m_dimvals, m_rmin, m_rmax,
                                    coord_ptr, C);
+    HDF5storage_type = CG_COMPACT;
+    return status;
 }
 
 /*****************************************************************************\
@@ -4964,6 +4984,16 @@ int cg_field_write(int file_number, int B, int Z, int S,
     cgns_sol *sol;
     int n, m_numdim;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
+     /* verify input */
+    if (cgi_check_strlen(fieldname)) return CG_ERROR;
+    if (type != CGNS_ENUMV(RealSingle) && type != CGNS_ENUMV(RealDouble) &&
+        type != CGNS_ENUMV(Integer) && type != CGNS_ENUMV(LongInteger)) {
+        cgi_error("Invalid datatype for solution array %s: %d",fieldname, type);
+        return CG_ERROR;
+    }
+
      /* get memory addresses */
     cg = cgi_get_file(file_number);
     if (cg == 0) return CG_ERROR;
@@ -5017,6 +5047,7 @@ int cg_field_partial_write(int file_number, int B, int Z, int S,
     cgns_zone *zone;
     cgns_sol *sol;
     int n, m_numdim;
+    int status;
 
      /* get memory addresses */
     cg = cgi_get_file(file_number);
@@ -5050,10 +5081,14 @@ int cg_field_partial_write(int file_number, int B, int Z, int S,
         m_dimvals[n] = m_rmax[n];
     }
 
-    return cg_field_general_write(file_number, B, Z, S, fieldname,
+    status = cg_field_general_write(file_number, B, Z, S, fieldname,
                                   type, s_rmin, s_rmax,
                                   type, m_numdim, m_dimvals, m_rmin, m_rmax,
                                   field_ptr, F);
+
+    HDF5storage_type = CG_COMPACT;
+    return status;
+
 }
 
 int cg_field_general_write(int fn, int B, int Z, int S, const char *fieldname,
@@ -5068,6 +5103,9 @@ int cg_field_general_write(int fn, int B, int Z, int S, const char *fieldname,
     cgns_zone *zone;
     cgns_sol *sol;
     int s_numdim;
+    int status;
+
+    HDF5storage_type = CG_CONTIGUOUS;
 
      /* verify input */
     if (cgi_check_strlen(fieldname)) return CG_ERROR;
@@ -5108,12 +5146,15 @@ int cg_field_general_write(int fn, int B, int Z, int S, const char *fieldname,
         s_dimvals[0] = sol->ptset->size_of_patch;
     }
 
-    return cgi_array_general_write(sol->id, &(sol->nfields),
+    status= cgi_array_general_write(sol->id, &(sol->nfields),
                                    &(sol->field), fieldname,
                                    cgns_rindindex, sol->rind_planes,
                                    s_type, s_numdim, s_dimvals, s_rmin, s_rmax,
                                    m_type, m_numdim, m_dimvals, m_rmin, m_rmax,
                                    field_ptr, F);
+    
+    HDF5storage_type = CG_COMPACT;
+    return status;
 }
 
 /*************************************************************************\
@@ -9969,6 +10010,8 @@ int cg_array_write(const char * ArrayName, CGNS_ENUMT(DataType_t) DataType,
     int n, ier=0;
     double posit_id;
 
+    HDF5storage_type = CG_CONTIGUOUS;
+
     CHECK_FILE_OPEN
 
      /* verify input */
@@ -10018,7 +10061,7 @@ int cg_array_write(const char * ArrayName, CGNS_ENUMT(DataType_t) DataType,
     if (cgi_posit_id(&posit_id)) return CG_ERROR;
     if (cgi_new_node(posit_id, array->name, "DataArray_t", &array->id,
         array->data_type, array->data_dim, array->dim_vals, Data)) return CG_ERROR;
-
+    HDF5storage_type = CG_COMPACT;
     return CG_OK;
 }
 
diff --git a/src/cgnslib.h b/src/cgnslib.h
index cc5cbf4..e753909 100644
--- a/src/cgnslib.h
+++ b/src/cgnslib.h
@@ -128,6 +128,12 @@
 #define CG_CONFIG_HDF5_COMPRESS   201
 #define CG_CONFIG_HDF5_MPI_COMM   202
 
+/* HDF5 dataset storage layout */
+
+#define CG_CONTIGUOUS 0
+#define CG_COMPACT    1
+#define CG_CHUNKED    2
+
 /* note: CG_CONFIG_RIND_ZERO is obsolete and considered a bug.  Users are given
  *       the option only for backwards compatibilty */
 #define CG_CONFIG_RIND_ZERO (void*)0
-- 
2.21.0

